<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<meta name="description" content="RQpedia - Moroccan Archaeological Sites Database with Radiocarbon Dating and Analytics"/>
<title>RQpedia — Moroccan Archaeological Sites</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/chart.js@4.4.0/dist/chart.umd.js"></script>
<style>
:root{
--gm-blue:#4285F4;--text:#202124;--muted:#5f6368;--bg:#fff;
--shadow:0 4px 16px rgba(0,0,0,0.12);--radius:12px;--error:#ff5252;--success:#34a853;
--chart-blue:#4285F4;--chart-green:#34a853;--chart-orange:#ff9800;--chart-red:#ff5252;--chart-purple:#9c27b0;
}
html,body{height:100%;margin:0;font-family:Roboto,Arial,sans-serif;color:var(--text);background:#fff;overflow:hidden}
#map{position:absolute;inset:0;height:100%;width:100%}
.map-controls{position:absolute;top:18px;left:50%;transform:translateX(-50%);z-index:1000;width:min(820px,calc(100% - 32px));pointer-events:none;display:flex;justify-content:center;flex-direction:column;gap:12px}
.search-card{pointer-events:auto;width:100%;background:#fff;border-radius:28px;padding:10px 14px;box-shadow:var(--shadow);display:flex;align-items:center;gap:12px;transition:box-shadow 0.2s ease}
.search-card:focus-within{box-shadow:0 6px 20px rgba(0,0,0,0.15)}
.search-input{flex:1;border:none;outline:none;background:transparent;font-size:15px;padding:8px;color:var(--text)}
.search-input::placeholder{color:var(--muted)}
.search-clear{border:none;background:none;color:var(--muted);cursor:pointer;display:none;padding:4px 8px;border-radius:4px;transition:background 0.2s ease}
.search-clear:hover{background:#f1f3f4}
.search-icon{width:34px;text-align:center;font-size:18px}
.autocomplete-list{position:absolute;top:74px;left:50%;transform:translateX(-50%);z-index:1100;width:min(760px,calc(100% - 64px));background:#fff;border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;max-height:320px;overflow-y:auto;display:none;max-width:100%}
.autocomplete-list::-webkit-scrollbar{width:6px}
.autocomplete-list::-webkit-scrollbar-track{background:#f1f3f4}
.autocomplete-list::-webkit-scrollbar-thumb{background:#ccc;border-radius:3px}
.autocomplete-list::-webkit-scrollbar-thumb:hover{background:#999}
.autocomplete-item{padding:12px 14px;cursor:pointer;font-size:14px;color:var(--text);transition:background 0.15s ease;border-bottom:1px solid #f1f3f4}
.autocomplete-item:last-child{border-bottom:none}
.autocomplete-item:hover,.autocomplete-item.highlighted{background:#f1f3f4}
.autocomplete-item-text{display:flex;align-items:center;gap:8px}
.autocomplete-item-icon{font-size:16px;color:var(--muted)}
.info-sheet{position:fixed;left:0;right:0;bottom:0;z-index:1200;max-width:1000px;margin:0 auto;border-radius:var(--radius) var(--radius) 0 0;background:#fff;box-shadow:0 -4px 20px rgba(0,0,0,0.2);transform:translateY(88%);transition:transform 0.34s cubic-bezier(0.4,0,0.2,1);display:flex;flex-direction:column;will-change:transform}
.info-sheet.open{transform:translateY(0)}
.sheet-handle{height:56px;display:flex;align-items:center;gap:12px;padding:0 16px;border-bottom:1px solid #eee;background:#fff;border-radius:var(--radius) var(--radius) 0 0;cursor:grab;user-select:none}
.sheet-handle:active{cursor:grabbing}
.handle-bar{width:36px;height:4px;border-radius:4px;background:#e0e0e0}
.sheet-title{font-weight:600;font-size:16px;color:var(--text);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;flex:1}
.sheet-sub{font-size:13px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.sheet-body{padding:14px;overflow-y:auto;max-height:62vh;scroll-behavior:smooth}
.sheet-body::-webkit-scrollbar{width:6px}
.sheet-body::-webkit-scrollbar-track{background:#f1f3f4}
.sheet-body::-webkit-scrollbar-thumb{background:#ccc;border-radius:3px}
.sheet-body::-webkit-scrollbar-thumb:hover{background:#999}
.sheet-footer{padding:12px 16px;border-top:1px solid #eee;background:#fff;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
.section-title{font-weight:600;margin:16px 0 10px;font-size:15px;display:flex;align-items:center;gap:8px;color:var(--text)}
.section-title:first-child{margin-top:0}
.badge{font-size:12px;font-weight:600;background:#e8f0fe;color:var(--gm-blue);padding:3px 8px;border-radius:999px;display:inline-block}
.badge.success{background:#e8f5e9;color:var(--success)}
.badge.warning{background:#fff3e0;color:#f57c00}
.badge.danger{background:#ffebee;color:var(--error)}
.stat-card{background:#f8f9fa;border:1px solid #e8eaed;border-radius:8px;padding:12px;margin-bottom:8px;display:flex;justify-content:space-between;align-items:center}
.stat-label{font-size:12px;color:var(--muted);font-weight:500;text-transform:uppercase;letter-spacing:0.5px}
.stat-value{font-size:18px;font-weight:600;color:var(--gm-blue)}
.stat-unit{font-size:11px;color:var(--muted);margin-left:4px}
.sample-card{background:#fafafa;border:1px solid #eee;border-radius:10px;padding:12px;margin-bottom:10px;box-shadow:0 2px 4px rgba(0,0,0,0.04);transition:box-shadow 0.2s ease}
.sample-card:hover{box-shadow:0 4px 8px rgba(0,0,0,0.08)}
.sample-header{font-weight:600;font-size:14px;margin-bottom:8px;color:var(--gm-blue)}
.sample-row{display:flex;justify-content:space-between;font-size:13px;margin-bottom:5px;align-items:flex-start;gap:12px}
.sample-row:last-child{margin-bottom:0}
.label{color:var(--muted);font-weight:500;min-width:80px;flex-shrink:0}
.sample-value{flex:1;text-align:right;word-break:break-word;line-height:1.4}
.chart-container{position:relative;width:100%;height:250px;margin:12px 0;background:#fafafa;border-radius:8px;padding:12px;border:1px solid #eee}
.chart-wrapper{position:relative;width:100%;height:100%}
.context-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:12px;margin-bottom:16px}
.context-item{background:#fff;border:1px solid #f1f3f4;border-radius:8px;padding:12px;transition:all 0.2s ease}
.context-item:hover{border-color:#e0e0e0;box-shadow:0 2px 8px rgba(0,0,0,0.06)}
.context-label{font-size:13px;font-weight:600;margin-bottom:8px;color:var(--text);text-transform:uppercase;letter-spacing:0.3px}
.tag-list{display:flex;flex-wrap:wrap;gap:6px}
.tag{background:#f1f3f4;color:#222;font-size:12px;padding:4px 10px;border-radius:999px;border:1px solid #e8eaed;transition:all 0.2s ease;word-break:break-word}
.tag:hover{background:#e8eaed;border-color:#d0d0d0}
.grid-value{font-size:14px;color:var(--text);font-weight:500;word-break:break-word;line-height:1.4}
.refs-container{display:flex;flex-direction:column;gap:8px;margin-top:8px;margin-bottom:0}
.ref-item{padding:12px;border-radius:8px;background:#f8f9fa;border:1px solid #e8eaed;transition:all 0.2s ease;cursor:pointer}
.ref-item:hover{background:#f1f3f4;border-color:#d0d0d0;transform:translateX(4px)}
.ref-item-title{font-weight:600;font-size:13px;color:var(--gm-blue);margin-bottom:6px;display:flex;align-items:center;gap:6px}
.ref-item-title::before{content:'📚';font-size:14px}
.ref-item-text{font-size:13px;color:var(--text);line-height:1.5;word-break:break-word;margin-bottom:8px;max-height:4.5em;overflow:hidden;display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical}
.ref-link-btn{display:inline-flex;align-items:center;gap:6px;padding:6px 12px;background:var(--gm-blue);color:#fff;border:none;border-radius:6px;font-size:12px;cursor:pointer;transition:all 0.2s ease;text-decoration:none;font-weight:500}
.ref-link-btn:hover{background:#3367d6;box-shadow:0 2px 6px rgba(66,133,244,0.3)}
.ref-link-btn:active{transform:scale(0.98)}
.tabs-container{display:flex;gap:8px;margin-bottom:12px;border-bottom:2px solid #eee;overflow-x:auto}
.tab-btn{background:none;border:none;padding:10px 16px;font-size:14px;color:var(--muted);cursor:pointer;border-bottom:3px solid transparent;transition:all 0.2s ease;white-space:nowrap;font-weight:500}
.tab-btn:hover{color:var(--text)}
.tab-btn.active{color:var(--gm-blue);border-bottom-color:var(--gm-blue)}
.tab-content{display:none}
.tab-content.active{display:block}
.copy-btn{background:var(--gm-blue);color:#fff;border:none;padding:10px 16px;border-radius:8px;cursor:pointer;font-weight:500;box-shadow:0 3px 10px rgba(66,133,244,0.3);font-size:14px;transition:all 0.2s ease}
.copy-btn:hover{background:#3367d6;box-shadow:0 4px 12px rgba(66,133,244,0.4)}
.copy-btn:active{transform:scale(0.98)}
.copy-btn:disabled{opacity:0.6;cursor:not-allowed}
.close-btn{background:none;border:none;color:var(--muted);cursor:pointer;padding:8px 12px;border-radius:6px;font-size:14px;transition:all 0.2s ease}
.close-btn:hover{background:#f1f3f4;color:var(--text)}
.error-banner{position:fixed;top:20px;left:50%;transform:translateX(-50%);background:var(--error);color:#fff;padding:14px 20px;border-radius:8px;z-index:2000;box-shadow:0 4px 12px rgba(0,0,0,0.15);animation:slideDown 0.3s ease}
.error-banner-content{display:flex;align-items:center;gap:12px;font-size:14px}
.error-banner-icon{font-size:20px}
@keyframes slideDown{from{transform:translateX(-50%) translateY(-120%);opacity:0}to{transform:translateX(-50%) translateY(0);opacity:1}}
.analytics-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px;margin-bottom:16px}
.analytics-item{background:#f8f9fa;border:1px solid #e8eaed;border-radius:8px;padding:12px;text-align:center}
.analytics-number{font-size:24px;font-weight:700;color:var(--gm-blue);margin-bottom:4px}
.analytics-label{font-size:12px;color:var(--muted);font-weight:500;text-transform:uppercase;letter-spacing:0.5px}
@media(max-width:599px){
 .map-controls{width:calc(100% - 16px);top:12px}
 .search-card{border-radius:24px;padding:8px 12px}
 .search-input{font-size:14px}
 .autocomplete-list{width:calc(100% - 16px);top:60px}
 .info-sheet{border-radius:20px 20px 0 0}
 .sheet-handle{padding:0 12px}
 .sheet-body{max-height:60vh;padding:12px}
 .context-grid{grid-template-columns:1fr}
 .sheet-footer{flex-direction:column;padding:10px 12px}
 .copy-btn{width:100%;flex:1}
 .sample-row{flex-direction:column;align-items:flex-start}
 .sample-value{text-align:left;margin-top:4px}
 .ref-item{padding:10px}
 .tabs-container{gap:4px;margin-bottom:8px}
 .tab-btn{padding:8px 12px;font-size:13px}
 .chart-container{height:200px;padding:8px}
 .analytics-grid{grid-template-columns:repeat(2,1fr)}
}
@media(min-width:600px) and (max-width:899px){
 .info-sheet{width:96%;left:2%;right:2%}
}
@media(min-width:900px){
 .info-sheet{left:50%;transform:translate(-50%,88%);width:min(900px,96%)}
 .info-sheet.open{transform:translate(-50%,0)}
 .analytics-grid{grid-template-columns:repeat(4,1fr)}
}
@media(prefers-reduced-motion:reduce){
 .info-sheet,.search-card,.ref-item,.copy-btn{transition:none}
 @keyframes slideDown{from{opacity:0}to{opacity:1}}
}
</style>
</head>
<body>
<div id="map" role="application" aria-label="Archaeological sites map"></div>
<div class="map-controls">
  <div class="search-card">
    <div class="search-icon">🔍</div>
    <input 
      id="search-input" 
      class="search-input" 
      placeholder="Search a Moroccan site (e.g., Taforalt)" 
      autocomplete="off"
      aria-label="Search archaeological sites"
      spellcheck="false"
    >
    <button 
      id="clear-btn" 
      class="search-clear" 
      aria-label="Clear search" 
      title="Clear search input"
    >✕</button>
  </div>
</div>
<div id="autocomplete-list" class="autocomplete-list" role="listbox" aria-label="Site suggestions"></div>

<div id="infoSheet" class="info-sheet" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="sheetTitle">
  <div class="sheet-handle" id="sheetHandle" role="button" tabindex="0" aria-label="Toggle site details">
    <div class="handle-bar"></div>
    <div style="display:flex;flex-direction:column;min-width:0">
      <div class="sheet-title" id="sheetTitle"></div>
      <div class="sheet-sub" id="sheetSub"></div>
    </div>
  </div>
  <div class="sheet-body" id="sheetBody" role="region" aria-live="polite"></div>
  <div class="sheet-footer">
    <button id="copyCoords" class="copy-btn" aria-label="Copy site coordinates to clipboard">Copy coordinates</button>
    <div style="flex:1"></div>
    <button id="closeSheet" class="close-btn" aria-label="Close site details">Close</button>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
'use strict';

// ============================================================================
// CONFIGURATION
// ============================================================================
const CONFIG = {
  GEO_FILE: 'output_full.geojson',
  REF_PAGE: 'ref.html',
  MAP: {
    CENTER: [31.8, -6],
    ZOOM: 6,
    MIN_ZOOM: 3,
    MAX_ZOOM: 18,
  },
  AUTOCOMPLETE_LIMIT: 10,
  AUTOCOMPLETE_DEBOUNCE: 150,
  SHEET_ANIMATION_DURATION: 340,
  COPY_SUCCESS_DURATION: 1200,
  ERROR_DISPLAY_DURATION: 5000,
  TOUCH_SWIPE_THRESHOLD: 100,
  MARKER_COLOR: '#4285F4',
};

// ============================================================================
// DOM CACHE
// ============================================================================
const DOM = {
  map: document.getElementById('map'),
  searchInput: document.getElementById('search-input'),
  clearBtn: document.getElementById('clear-btn'),
  autocompleteList: document.getElementById('autocomplete-list'),
  infoSheet: document.getElementById('infoSheet'),
  sheetHandle: document.getElementById('sheetHandle'),
  sheetTitle: document.getElementById('sheetTitle'),
  sheetSub: document.getElementById('sheetSub'),
  sheetBody: document.getElementById('sheetBody'),
  copyBtn: document.getElementById('copyCoords'),
  closeBtn: document.getElementById('closeSheet'),
};

// ============================================================================
// APPLICATION STATE
// ============================================================================
const AppState = {
  sites: [],
  currentMarker: null,
  currentSite: null,
  autocompleteHighlightIndex: -1,
  isLoading: false,
  debounceTimer: null,
  touchStartY: 0,
  sheetStartY: 0,
  isDraggingSheet: false,
  chartInstances: {},

  setSites(sites) {
    this.sites = sites;
  },

  setCurrentSite(site) {
    this.currentSite = site;
  },

  setMarker(coordinates) {
    this.clearMarker();
    this.currentMarker = L.marker(coordinates, {
      icon: L.icon({
        iconUrl: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%234285F4"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm0-13c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5z"/></svg>',
        iconSize: [32, 32],
        iconAnchor: [16, 16],
        popupAnchor: [0, -16],
        className: 'leaflet-marker-icon'
      })
    }).addTo(map);
  },

  clearMarker() {
    if (this.currentMarker) {
      map.removeLayer(this.currentMarker);
      this.currentMarker = null;
    }
  },

  resetAutoComplete() {
    this.autocompleteHighlightIndex = -1;
  },

  destroyCharts() {
    Object.values(this.chartInstances).forEach(chart => {
      if (chart) chart.destroy();
    });
    this.chartInstances = {};
  },

  reset() {
    this.clearMarker();
    this.currentSite = null;
    this.resetAutoComplete();
    this.destroyCharts();
  },

  startDebounce(callback, delay) {
    clearTimeout(this.debounceTimer);
    this.debounceTimer = setTimeout(callback, delay);
  }
};

// ============================================================================
// MAP INITIALIZATION
// ============================================================================
const map = L.map('map').setView(CONFIG.MAP.CENTER, CONFIG.MAP.ZOOM);
map.setMinZoom(CONFIG.MAP.MIN_ZOOM);
map.setMaxZoom(CONFIG.MAP.MAX_ZOOM);

L.tileLayer(
  'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
  {
    attribution: '&copy; Esri, Earthstar Geographics',
    maxZoom: CONFIG.MAP.MAX_ZOOM,
    maxNativeZoom: 18,
  }
).addTo(map);

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Formats a reference object into a readable citation string with proper spacing
 * @param {*} ref - Reference (object, string, or array)
 * @returns {string} Formatted reference string
 */
function formatReference(ref) {
  if (!ref) return '';

  if (typeof ref === 'string') {
    const trimmed = ref.trim();
    return trimmed && trimmed !== '[object Object]' ? trimmed : '';
  }

  if (Array.isArray(ref)) {
    return ref
      .map(r => formatReference(r))
      .filter(r => r)
      .join('; ');
  }

  if (typeof ref === 'object') {
    const parts = [];

    if (ref.author || ref.authors) {
      const author = String(ref.author || ref.authors).trim();
      if (author && author !== '[object Object]') {
        parts.push(author);
      }
    }

    if (ref.year) {
      const year = String(ref.year).trim();
      if (year && year !== '[object Object]') {
        parts.push(`(${year})`);
      }
    }

    if (ref.title) {
      const title = String(ref.title).trim();
      if (title && title !== '[object Object]') {
        parts.push(`"${title}"`);
      }
    }

    if (ref.journal) {
      const journal = String(ref.journal).trim();
      if (journal && journal !== '[object Object]') {
        parts.push(journal);
      }
    }

    if (ref.volume) {
      const volume = String(ref.volume).trim();
      if (volume && volume !== '[object Object]') {
        parts.push(`Vol. ${volume}`);
      }
    }

    if (ref.issue) {
      const issue = String(ref.issue).trim();
      if (issue && issue !== '[object Object]') {
        parts.push(`No. ${issue}`);
      }
    }

    if (ref.pages) {
      const pages = String(ref.pages).trim();
      if (pages && pages !== '[object Object]') {
        parts.push(`pp. ${pages}`);
      }
    }

    if (ref.publisher) {
      const publisher = String(ref.publisher).trim();
      if (publisher && publisher !== '[object Object]') {
        parts.push(publisher);
      }
    }

    if (ref.doi) {
      const doi = String(ref.doi).trim();
      if (doi && doi !== '[object Object]') {
        parts.push(`DOI: ${doi}`);
      }
    }

    if (ref.url) {
      const url = String(ref.url).trim();
      if (url && url !== '[object Object]') {
        parts.push(url);
      }
    }

    if (parts.length === 0) {
      const jsonStr = JSON.stringify(ref);
      return jsonStr !== '{}' ? jsonStr : '';
    }

    return parts.join(' ');
  }

  return '';
}

/**
 * Safely converts any value to a string
 * @param {*} value - Any value
 * @returns {string} String representation
 */
function toString(value) {
  if (value === null || value === undefined) return '';
  if (typeof value === 'string') return value;
  if (typeof value === 'object') {
    if (Array.isArray(value)) {
      return value.map(v => toString(v)).filter(v => v).join('; ');
    }
    return formatReference(value);
  }
  return String(value);
}

/**
 * Escapes HTML special characters to prevent XSS
 * @param {string} text - Text to escape
 * @returns {string} Escaped text
 */
function escapeHtml(text) {
  const str = toString(text);
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

/**
 * Encodes a reference string for URL parameter
 * @param {string} ref - Reference string
 * @returns {string} Encoded reference
 */
function encodeRefParam(ref) {
  return encodeURIComponent(toString(ref).trim());
}

/**
 * Cleans and normalizes a delimited string into an array
 * @param {string} str - Input string with delimiters
 * @returns {string[]} Cleaned array of strings
 */
function cleanList(str) {
  if (!str) return [];
  const strValue = toString(str);
  if (!strValue) return [];
  const cleaned = strValue
    .split(/[;,]+/)
    .map(s => s.trim())
    .filter(v => v && v !== '.' && v !== '-' && v !== '[object Object]');
  return [...new Set(cleaned)];
}

/**
 * Joins an array of strings with a separator
 * @param {string[]} list - Array of strings
 * @returns {string} Joined string or '—'
 */
function joinAcademic(list) {
  return (list && list.length > 0) ? list.join(' · ') : '—';
}

/**
 * Calculates average coordinates from multiple features
 * @param {Object[]} features - GeoJSON features
 * @returns {Object} Object with lat and lng properties
 */
function calculateAverageCoordinates(features) {
  if (!features || features.length === 0) {
    return { lat: 0, lng: 0 };
  }

  const totals = features.reduce(
    ([sumLat, sumLng], f) => {
      try {
        const [lng, lat] = f.geometry.coordinates;
        const parsedLat = parseFloat(lat);
        const parsedLng = parseFloat(lng);
        
        if (isNaN(parsedLat) || isNaN(parsedLng)) {
          return [sumLat, sumLng];
        }
        
        return [sumLat + parsedLat, sumLng + parsedLng];
      } catch {
        return [sumLat, sumLng];
      }
    },
    [0, 0]
  );

  return {
    lat: totals[0] / features.length,
    lng: totals[1] / features.length,
  };
}

/**
 * Shows error notification banner
 * @param {string} message - Error message
 * @param {number} duration - Display duration in milliseconds
 */
function showError(message, duration = CONFIG.ERROR_DISPLAY_DURATION) {
  const errorDiv = document.createElement('div');
  errorDiv.className = 'error-banner';
  errorDiv.setAttribute('role', 'alert');
  errorDiv.innerHTML = `
    <div class="error-banner-content">
      <span class="error-banner-icon">⚠️</span>
      <span>${escapeHtml(message)}</span>
    </div>
  `;
  document.body.appendChild(errorDiv);
  
  setTimeout(() => {
    errorDiv.style.opacity = '0';
    errorDiv.style.transition = 'opacity 0.3s ease';
    setTimeout(() => errorDiv.remove(), 300);
  }, duration);
}

/**
 * Shows success feedback in the copy button
 */
function showCopySuccess() {
  const originalText = DOM.copyBtn.textContent;
  DOM.copyBtn.innerHTML = '✓ Copied!';
  DOM.copyBtn.disabled = true;
  
  setTimeout(() => {
    DOM.copyBtn.textContent = originalText;
    DOM.copyBtn.disabled = false;
  }, CONFIG.COPY_SUCCESS_DURATION);
}

// ============================================================================
// DATA LOADING AND PROCESSING
// ============================================================================

/**
 * Fetches and processes GeoJSON data
 */
async function load() {
  AppState.isLoading = true;
  try {
    const response = await fetch(CONFIG.GEO_FILE);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const geojson = await response.json();
    
    if (!geojson.features || !Array.isArray(geojson.features)) {
      throw new Error('Invalid GeoJSON format: missing features array');
    }
    
    if (geojson.features.length === 0) {
      throw new Error('GeoJSON contains no features');
    }
    
    processGeoJSON(geojson);
  } catch (error) {
    console.error('Failed to load sites:', error);
    showError(`Unable to load archaeological sites: ${error.message}`);
  } finally {
    AppState.isLoading = false;
  }
}

/**
 * Processes GeoJSON features and groups them by site name
 * @param {Object} geojson - GeoJSON object
 */
function processGeoJSON(geojson) {
  const grouped = {};
  
  for (const feature of geojson.features) {
    try {
      if (!feature.geometry || feature.geometry.type !== 'Point') {
        console.warn('Skipping non-Point feature:', feature);
        continue;
      }
      
      const props = feature.properties || {};
      const name = toString(props.site || 'Unknown').trim();
      
      if (!name || name.length === 0) {
        console.warn('Skipping feature with empty site name');
        continue;
      }
      
      if (!grouped[name]) grouped[name] = [];
      grouped[name].push(feature);
    } catch (error) {
      console.error('Error processing feature:', error);
      continue;
    }
  }

  const sites = Object.entries(grouped)
    .map(([name, features]) => processSiteGroup(name, features))
    .filter(site => site !== null)
    .sort((a, b) => a.name.localeCompare(b.name));

  AppState.setSites(sites);
  console.log(`Loaded ${sites.length} archaeological sites`);
}

/**
 * Extracts all available properties from features
 * @param {Object[]} features - GeoJSON features
 * @returns {Object} All properties keyed by property name
 */
function extractAllProperties(features) {
  const allProps = {};
  
  for (const feature of features) {
    const props = feature.properties || {};
    for (const [key, value] of Object.entries(props)) {
      if (!allProps[key]) {
        allProps[key] = [];
      }
      if (value) {
        allProps[key].push(value);
      }
    }
  }
  
  return allProps;
}

/**
 * Calculates statistics for numeric data
 * @param {Array} values - Array of values
 * @returns {Object} Statistics object
 */
function calculateStats(values) {
  const numericValues = values
    .map(v => parseFloat(v))
    .filter(v => !isNaN(v));
  
  if (numericValues.length === 0) {
    return null;
  }
  
  numericValues.sort((a, b) => a - b);
  const min = numericValues[0];
  const max = numericValues[numericValues.length - 1];
  const avg = numericValues.reduce((a, b) => a + b, 0) / numericValues.length;
  const median = numericValues[Math.floor(numericValues.length / 2)];
  
  return { min, max, avg, median, count: numericValues.length };
}

/**
 * Processes a group of features for a single site
 * @param {string} name - Site name
 * @param {Object[]} features - GeoJSON features
 * @returns {Object|null} Processed site object or null
 */
function processSiteGroup(name, features) {
  try {
    const { lat, lng } = calculateAverageCoordinates(features);
    
    if (isNaN(lat) || isNaN(lng)) {
      console.warn(`Invalid coordinates for site ${name}`);
      return null;
    }

    const props = features.map(f => f.properties || {});
    const allProps = extractAllProperties(features);
    
    const merge = (key) => cleanList(
      props
        .map(p => {
          const val = p[key];
          return val ? toString(val) : '';
        })
        .join('; ')
    );
    
    const samples = props
      .map(p => ({
        labnr: toString(p.labnr || '').trim(),
        bp: toString(p.bp || '').trim(),
        std: toString(p.std || '').trim(),
        delta: toString((p['delta c13'] || p.delta_c13) || '').trim(),
        material: toString(p.material || '').trim(),
        reference: toString((p.reference || p.references) || '').trim()
      }))
      .filter(s => s.bp || s.labnr || s.reference)
      .sort((a, b) => {
        const bpA = parseFloat(a.bp) || 0;
        const bpB = parseFloat(b.bp) || 0;
        return bpB - bpA;
      });

    const refsSet = new Set();
    samples.forEach(s => {
      if (s.reference) {
        const refValue = toString(s.reference).trim();
        if (refValue && refValue !== '[object Object]') {
          refsSet.add(refValue);
        }
      }
    });
    
    const refs = Array.from(refsSet);

    // Calculate statistics
    const bpValues = samples.map(s => s.bp).filter(v => v);
    const bpStats = calculateStats(bpValues);

    return {
      name,
      lat,
      lng,
      base: {
        site_type: joinAcademic(merge('site_type')),
        feature_type: joinAcademic(merge('feature_type')),
        periods: merge('periods'),
        typo: merge('typochronological_units'),
        eco: merge('ecochronological_units'),
        country: joinAcademic(merge('country')),
      },
      samples,
      refs,
      allProps,
      bpStats,
      features,
    };
  } catch (error) {
    console.error(`Error processing site ${name}:`, error);
    return null;
  }
}

// ============================================================================
// REFERENCE HANDLING
// ============================================================================

/**
 * Creates a clickable reference item element
 * @param {string} ref - Reference string (already formatted)
 * @returns {HTMLElement|null} Reference item element or null
 */
function createRefItemElement(ref) {
  const refText = toString(ref).trim();
  
  if (!refText || refText === '[object Object]') {
    console.warn('Skipping invalid reference:', ref);
    return null;
  }

  const item = document.createElement('div');
  item.className = 'ref-item';
  
  const title = document.createElement('div');
  title.className = 'ref-item-title';
  title.textContent = 'Reference';
  
  const textDiv = document.createElement('div');
  textDiv.className = 'ref-item-text';
  textDiv.textContent = refText;
  textDiv.title = refText;
  
  const button = document.createElement('a');
  button.className = 'ref-link-btn';
  button.href = `${CONFIG.REF_PAGE}?ref=${encodeRefParam(refText)}&site=${encodeRefParam(AppState.currentSite?.name || '')}`;
  button.target = '_blank';
  button.rel = 'noopener noreferrer';
  button.innerHTML = '<span>📖</span><span>View Reference</span>';
  
  item.appendChild(title);
  item.appendChild(textDiv);
  item.appendChild(button);
  
  return item;
}

// ============================================================================
// CHART FUNCTIONS
// ============================================================================

/**
 * Creates a radiocarbon age distribution chart
 * @param {Array} samples - Sample data
 * @param {string} containerId - Container ID
 */
function createAgeDistributionChart(samples, containerId) {
  const canvas = document.getElementById(containerId);
  if (!canvas) return;

  const bpValues = samples
    .map(s => ({ bp: parseFloat(s.bp), labnr: s.labnr }))
    .filter(s => !isNaN(s.bp))
    .sort((a, b) => a.bp - b.bp);

  if (bpValues.length === 0) return;

  const ctx = canvas.getContext('2d');
  
  if (AppState.chartInstances[containerId]) {
    AppState.chartInstances[containerId].destroy();
  }

  AppState.chartInstances[containerId] = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: bpValues.map((v, i) => `Sample ${i + 1}`),
      datasets: [{
        label: 'Age (BP)',
        data: bpValues.map(v => v.bp),
        backgroundColor: '#4285F4',
        borderColor: '#3367d6',
        borderWidth: 1,
        borderRadius: 4,
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: true,
          labels: {
            font: { size: 12 },
            color: '#202124'
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            font: { size: 11 },
            color: '#5f6368'
          },
          grid: {
            color: '#f1f3f4'
          }
        },
        x: {
          ticks: {
            font: { size: 10 },
            color: '#5f6368'
          },
          grid: {
            display: false
          }
        }
      }
    }
  });
}

/**
 * Creates a material distribution chart
 * @param {Array} samples - Sample data
 * @param {string} containerId - Container ID
 */
function createMaterialChart(samples, containerId) {
  const canvas = document.getElementById(containerId);
  if (!canvas) return;

  const materialCounts = {};
  samples.forEach(s => {
    if (s.material) {
      materialCounts[s.material] = (materialCounts[s.material] || 0) + 1;
    }
  });

  if (Object.keys(materialCounts).length === 0) return;

  const ctx = canvas.getContext('2d');
  
  if (AppState.chartInstances[containerId]) {
    AppState.chartInstances[containerId].destroy();
  }

  const colors = ['#4285F4', '#34a853', '#ff9800', '#ff5252', '#9c27b0', '#00bcd4'];

  AppState.chartInstances[containerId] = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: Object.keys(materialCounts),
      datasets: [{
        data: Object.values(materialCounts),
        backgroundColor: colors.slice(0, Object.keys(materialCounts).length),
        borderColor: '#fff',
        borderWidth: 2
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'bottom',
          labels: {
            font: { size: 11 },
            color: '#202124',
            padding: 12
          }
        }
      }
    }
  });
}

/**
 * Creates a chronological distribution chart
 * @param {Array} samples - Sample data
 * @param {string} containerId - Container ID
 */
function createChronologicalChart(samples, containerId) {
  const canvas = document.getElementById(containerId);
  if (!canvas) return;

  const bpValues = samples
    .map(s => parseFloat(s.bp))
    .filter(v => !isNaN(v))
    .sort((a, b) => b - a);

  if (bpValues.length === 0) return;

  // Create bins for histogram
  const minBP = Math.min(...bpValues);
  const maxBP = Math.max(...bpValues);
  const binSize = (maxBP - minBP) / 10 || 100;
  const bins = {};
  
  for (let i = 0; i <= 10; i++) {
    const binStart = maxBP - (i * binSize);
    bins[Math.round(binStart)] = 0;
  }

  bpValues.forEach(bp => {
    const binKey = Math.round(Math.floor((bp - minBP) / binSize) * binSize + minBP);
    bins[binKey] = (bins[binKey] || 0) + 1;
  });

  const ctx = canvas.getContext('2d');
  
  if (AppState.chartInstances[containerId]) {
    AppState.chartInstances[containerId].destroy();
  }

  AppState.chartInstances[containerId] = new Chart(ctx, {
    type: 'line',
    data: {
      labels: Object.keys(bins).map(k => `${Math.round(k)} BP`),
      datasets: [{
        label: 'Sample Count',
        data: Object.values(bins),
        borderColor: '#4285F4',
        backgroundColor: 'rgba(66, 133, 244, 0.1)',
        borderWidth: 2,
        tension: 0.4,
        fill: true,
        pointRadius: 4,
        pointBackgroundColor: '#4285F4',
        pointBorderColor: '#fff',
        pointBorderWidth: 2
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: true,
          labels: {
            font: { size: 12 },
            color: '#202124'
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            font: { size: 11 },
            color: '#5f6368'
          },
          grid: {
            color: '#f1f3f4'
          }
        },
        x: {
          ticks: {
            font: { size: 10 },
            color: '#5f6368',
            maxRotation: 45
          },
          grid: {
            display: false
          }
        }
      }
    }
  });
}

// ============================================================================
// AUTOCOMPLETE FUNCTIONALITY
// ============================================================================

/**
 * Updates autocomplete suggestions based on query
 * @param {string} query - Search query
 */
function suggest(query) {
  DOM.autocompleteList.innerHTML = '';
  AppState.resetAutoComplete();
  
  const trimmedQuery = query.trim();
  
  if (!trimmedQuery) {
    DOM.autocompleteList.style.display = 'none';
    return;
  }

  const lowerQuery = trimmedQuery.toLowerCase();
  const matches = AppState.sites
    .filter(s => s.name.toLowerCase().includes(lowerQuery))
    .slice(0, CONFIG.AUTOCOMPLETE_LIMIT);

  if (!matches.length) {
    DOM.autocompleteList.style.display = 'none';
    return;
  }

  matches.forEach((site, index) => {
    const item = document.createElement('div');
    item.className = 'autocomplete-item';
    item.setAttribute('role', 'option');
    item.setAttribute('data-index', index);
    
    const highlightStart = site.name.toLowerCase().indexOf(lowerQuery);
    const before = site.name.slice(0, highlightStart);
    const highlight = site.name.slice(highlightStart, highlightStart + lowerQuery.length);
    const after = site.name.slice(highlightStart + lowerQuery.length);
    
    const textSpan = document.createElement('span');
    const beforeSpan = document.createElement('span');
    beforeSpan.textContent = before;
    
    const highlightSpan = document.createElement('strong');
    highlightSpan.textContent = highlight;
    
    const afterSpan = document.createElement('span');
    afterSpan.textContent = after;
    
    textSpan.appendChild(beforeSpan);
    textSpan.appendChild(highlightSpan);
    textSpan.appendChild(afterSpan);
    
    item.innerHTML = '<span class="autocomplete-item-icon">📍</span>';
    item.appendChild(textSpan);
    
    item.addEventListener('click', () => {
      selectSite(site);
    });
    
    DOM.autocompleteList.appendChild(item);
  });

  DOM.autocompleteList.style.display = 'block';
}

/**
 * Handles keyboard navigation in autocomplete
 * @param {number} direction - Direction to navigate (-1 or 1)
 */
function navigateAutocomplete(direction) {
  const items = Array.from(DOM.autocompleteList.querySelectorAll('.autocomplete-item'));
  
  if (items.length === 0) return;
  
  const newIndex = Math.max(
    -1,
    Math.min(
      AppState.autocompleteHighlightIndex + direction,
      items.length - 1
    )
  );
  
  if (AppState.autocompleteHighlightIndex >= 0 && items[AppState.autocompleteHighlightIndex]) {
    items[AppState.autocompleteHighlightIndex].classList.remove('highlighted');
  }
  
  AppState.autocompleteHighlightIndex = newIndex;
  
  if (newIndex >= 0 && items[newIndex]) {
    items[newIndex].classList.add('highlighted');
    items[newIndex].scrollIntoView({ block: 'nearest' });
  }
}

/**
 * Selects a site and displays its details
 * @param {Object} site - Site object
 */
function selectSite(site) {
  try {
    AppState.reset();
    AppState.setCurrentSite(site);
    AppState.setMarker([site.lat, site.lng]);
    map.setView([site.lat, site.lng], 9);
    showSiteDetails(site);
    DOM.autocompleteList.style.display = 'none';
    DOM.searchInput.value = site.name;
    DOM.clearBtn.style.display = 'block';
  } catch (error) {
    console.error('Error selecting site:', error);
    showError('Error selecting site. Please try again.');
  }
}

// ============================================================================
// UI RENDERING
// ============================================================================

/**
 * Renders a section with tags - returns DOM element
 * @param {string} label - Section label
 * @param {string[]} array - Array of tags
 * @returns {HTMLElement|null} Element or null
 */
function renderTagsElement(label, array) {
  if (!array || !array.length) return null;
  
  const container = document.createElement('div');
  container.className = 'context-item';
  
  const labelEl = document.createElement('div');
  labelEl.className = 'context-label';
  labelEl.textContent = label;
  container.appendChild(labelEl);
  
  const tagList = document.createElement('div');
  tagList.className = 'tag-list';
  
  array.forEach(tag => {
    const tagEl = document.createElement('span');
    tagEl.className = 'tag';
    const tagText = toString(tag).trim();
    if (tagText && tagText !== '[object Object]') {
      tagEl.textContent = tagText;
      tagList.appendChild(tagEl);
    }
  });
  
  if (tagList.children.length === 0) return null;
  
  container.appendChild(tagList);
  return container;
}

/**
 * Renders a single radiocarbon sample - returns DOM element
 * @param {Object} sample - Sample object
 * @returns {HTMLElement} Element
 */
function renderSampleElement(sample) {
  const card = document.createElement('div');
  card.className = 'sample-card';
  
  if (sample.labnr) {
    const header = document.createElement('div');
    header.className = 'sample-header';
    header.textContent = sample.labnr;
    card.appendChild(header);
  }
  
  const rows = [
    { label: 'Age', value: sample.bp ? `${sample.bp} BP` : '—' },
    ...(sample.std ? [{ label: '±', value: sample.std }] : []),
    ...(sample.delta ? [{ label: 'δ¹³C', value: `${sample.delta} ‰` }] : []),
    ...(sample.material ? [{ label: 'Material', value: sample.material }] : []),
  ];

  rows.forEach(({ label, value }) => {
    const row = document.createElement('div');
    row.className = 'sample-row';
    
    const labelEl = document.createElement('div');
    labelEl.className = 'label';
    labelEl.textContent = label;
    
    const valueEl = document.createElement('div');
    valueEl.className = 'sample-value';
    valueEl.textContent = value;
    
    row.appendChild(labelEl);
    row.appendChild(valueEl);
    card.appendChild(row);
  });

  if (sample.reference) {
    const refText = toString(sample.reference).trim();
    if (refText && refText !== '[object Object]') {
      const row = document.createElement('div');
      row.className = 'sample-row';
      
      const labelEl = document.createElement('div');
      labelEl.className = 'label';
      labelEl.textContent = 'Ref';
      
      const valueEl = document.createElement('div');
      valueEl.className = 'sample-value';
      valueEl.textContent = refText;
      
      row.appendChild(labelEl);
      row.appendChild(valueEl);
      card.appendChild(row);
    }
  }
  
  return card;
}

/**
 * Creates analytics summary for site
 * @param {Object} site - Site object
 * @returns {HTMLElement} Analytics element
 */
function createAnalyticsSummary(site) {
  const container = document.createElement('div');
  container.className = 'analytics-grid';

  const stats = [
    { label: 'Samples', value: site.samples.length, icon: '🧪' },
    { label: 'References', value: site.refs.length, icon: '📚' },
  ];

  if (site.bpStats) {
    stats.push(
      { label: 'Earliest', value: `${Math.round(site.bpStats.max)} BP`, icon: '📅' },
      { label: 'Latest', value: `${Math.round(site.bpStats.min)} BP`, icon: '⏱️' }
    );
  }

  stats.forEach(stat => {
    const item = document.createElement('div');
    item.className = 'analytics-item';
    
    const number = document.createElement('div');
    number.className = 'analytics-number';
    number.textContent = stat.value;
    
    const label = document.createElement('div');
    label.className = 'analytics-label';
    label.textContent = stat.label;
    
    item.appendChild(number);
    item.appendChild(label);
    container.appendChild(item);
  });

  return container;
}

/**
 * Displays site details in the info sheet
 * @param {Object} site - Site object
 */
function showSiteDetails(site) {
  try {
    AppState.setCurrentSite(site);
    
    DOM.sheetTitle.textContent = site.name;
    DOM.sheetSub.textContent = `${site.lat.toFixed(4)}, ${site.lng.toFixed(4)}`;

    DOM.sheetBody.innerHTML = '';

    // Analytics Summary
    const analyticsSummary = createAnalyticsSummary(site);
    DOM.sheetBody.appendChild(analyticsSummary);

    // Tabs for different sections
    const tabsContainer = document.createElement('div');
    tabsContainer.className = 'tabs-container';

    const tabs = ['samples', 'analytics', 'context', 'references'];
    const tabButtons = {};
    const tabContents = {};

    tabs.forEach(tab => {
      const btn = document.createElement('button');
      btn.className = `tab-btn ${tab === 'samples' ? 'active' : ''}`;
      btn.textContent = tab.charAt(0).toUpperCase() + tab.slice(1);
      btn.setAttribute('aria-label', `View ${tab}`);
      
      btn.addEventListener('click', () => {
        Object.values(tabButtons).forEach(b => b.classList.remove('active'));
        Object.values(tabContents).forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        tabContents[tab].classList.add('active');
      });
      
      tabButtons[tab] = btn;
      tabsContainer.appendChild(btn);
    });

    DOM.sheetBody.appendChild(tabsContainer);

    // ===== SAMPLES TAB =====
    tabContents.samples = document.createElement('div');
    tabContents.samples.className = 'tab-content active';

    if (site.samples && site.samples.length) {
      const titleEl = document.createElement('div');
      titleEl.className = 'section-title';
      
      const titleText = document.createElement('span');
      titleText.textContent = 'Radiocarbon Samples';
      titleEl.appendChild(titleText);
      
      const badge = document.createElement('span');
      badge.className = 'badge';
      badge.textContent = site.samples.length;
      titleEl.appendChild(badge);
      
      tabContents.samples.appendChild(titleEl);
      
      site.samples.forEach(sample => {
        tabContents.samples.appendChild(renderSampleElement(sample));
      });
    }

    DOM.sheetBody.appendChild(tabContents.samples);

    // ===== ANALYTICS TAB =====
    tabContents.analytics = document.createElement('div');
    tabContents.analytics.className = 'tab-content';

    if (site.samples.length > 0) {
      const titleEl = document.createElement('div');
      titleEl.className = 'section-title';
      titleEl.textContent = 'Data Visualizations';
      tabContents.analytics.appendChild(titleEl);

      // Age Distribution Chart
      const ageChartContainer = document.createElement('div');
      ageChartContainer.className = 'chart-container';
      const ageChart = document.createElement('canvas');
      ageChart.id = `ageChart-${Date.now()}`;
      ageChartContainer.appendChild(ageChart);
      tabContents.analytics.appendChild(ageChartContainer);

      // Material Distribution Chart
      const materialChartContainer = document.createElement('div');
      materialChartContainer.className = 'chart-container';
      const materialChart = document.createElement('canvas');
      materialChart.id = `materialChart-${Date.now()}`;
      materialChartContainer.appendChild(materialChart);
      tabContents.analytics.appendChild(materialChartContainer);

      // Chronological Distribution Chart
      const chronoChartContainer = document.createElement('div');
      chronoChartContainer.className = 'chart-container';
      const chronoChart = document.createElement('canvas');
      chronoChart.id = `chronoChart-${Date.now()}`;
      chronoChartContainer.appendChild(chronoChart);
      tabContents.analytics.appendChild(chronoChartContainer);

      // Render charts after elements are added to DOM
      setTimeout(() => {
        createAgeDistributionChart(site.samples, ageChart.id);
        createMaterialChart(site.samples, materialChart.id);
        createChronologicalChart(site.samples, chronoChart.id);
      }, 0);
    }

    DOM.sheetBody.appendChild(tabContents.analytics);

    // ===== CONTEXT TAB =====
    tabContents.context = document.createElement('div');
    tabContents.context.className = 'tab-content';

    const contextTitleEl = document.createElement('div');
    contextTitleEl.className = 'section-title';
    contextTitleEl.textContent = 'Context';
    tabContents.context.appendChild(contextTitleEl);
    
    const contextGrid = document.createElement('div');
    contextGrid.className = 'context-grid';
    
    [
      { label: 'Periods', data: site.base.periods },
      { label: 'Typochronological units', data: site.base.typo },
      { label: 'Ecochronological units', data: site.base.eco },
    ].forEach(({ label, data }) => {
      const el = renderTagsElement(label, data);
      if (el) contextGrid.appendChild(el);
    });
    
    if (site.base.site_type !== '—') {
      const el = document.createElement('div');
      el.className = 'context-item';
      const label = document.createElement('div');
      label.className = 'context-label';
      label.textContent = 'Site type';
      const value = document.createElement('div');
      value.className = 'grid-value';
      value.textContent = site.base.site_type;
      el.appendChild(label);
      el.appendChild(value);
      contextGrid.appendChild(el);
    }
    
    if (site.base.feature_type !== '—') {
      const el = document.createElement('div');
      el.className = 'context-item';
      const label = document.createElement('div');
      label.className = 'context-label';
      label.textContent = 'Feature type';
      const value = document.createElement('div');
      value.className = 'grid-value';
      value.textContent = site.base.feature_type;
      el.appendChild(label);
      el.appendChild(value);
      contextGrid.appendChild(el);
    }
    
    if (site.base.country !== '—') {
      const el = document.createElement('div');
      el.className = 'context-item';
      const label = document.createElement('div');
      label.className = 'context-label';
      label.textContent = 'Country';
      const value = document.createElement('div');
      value.className = 'grid-value';
      value.textContent = site.base.country;
      el.appendChild(label);
      el.appendChild(value);
      contextGrid.appendChild(el);
    }
    
    tabContents.context.appendChild(contextGrid);
    DOM.sheetBody.appendChild(tabContents.context);

    // ===== REFERENCES TAB =====
    tabContents.references = document.createElement('div');
    tabContents.references.className = 'tab-content';

    if (site.refs && site.refs.length) {
      const refsTitleEl = document.createElement('div');
      refsTitleEl.className = 'section-title';
      refsTitleEl.textContent = 'References';
      tabContents.references.appendChild(refsTitleEl);
      
      const refsContainer = document.createElement('div');
      refsContainer.className = 'refs-container';
      
      site.refs.forEach(ref => {
        const refEl = createRefItemElement(ref);
        if (refEl) {
          refsContainer.appendChild(refEl);
        }
      });
      
      if (refsContainer.children.length > 0) {
        tabContents.references.appendChild(refsContainer);
      }
    }

    DOM.sheetBody.appendChild(tabContents.references);

    DOM.infoSheet.classList.add('open');
    DOM.infoSheet.setAttribute('aria-hidden', 'false');
  } catch (error) {
    console.error('Error displaying site details:', error);
    showError('Error displaying site details. Please try again.');
  }
}

/**
 * Closes the info sheet
 */
function closeInfoSheet() {
  DOM.infoSheet.classList.remove('open');
  DOM.infoSheet.setAttribute('aria-hidden', 'true');
  AppState.destroyCharts();
}

/**
 * Toggles the info sheet visibility
 */
function toggleInfoSheet() {
  if (DOM.infoSheet.classList.contains('open')) {
    closeInfoSheet();
  } else if (AppState.currentSite) {
    showSiteDetails(AppState.currentSite);
  }
}

// ============================================================================
// EVENT LISTENERS
// ============================================================================

DOM.searchInput.addEventListener('input', (e) => {
  DOM.clearBtn.style.display = e.target.value ? 'block' : 'none';
  AppState.startDebounce(
    () => suggest(e.target.value),
    CONFIG.AUTOCOMPLETE_DEBOUNCE
  );
});

DOM.searchInput.addEventListener('keydown', (e) => {
  const list = DOM.autocompleteList;
  const isListOpen = list.style.display !== 'none';

  switch (e.key) {
    case 'ArrowDown':
      if (isListOpen) {
        e.preventDefault();
        navigateAutocomplete(1);
      }
      break;
    case 'ArrowUp':
      if (isListOpen) {
        e.preventDefault();
        navigateAutocomplete(-1);
      }
      break;
    case 'Enter':
      e.preventDefault();
      if (AppState.autocompleteHighlightIndex >= 0) {
        const items = list.querySelectorAll('.autocomplete-item');
        if (items[AppState.autocompleteHighlightIndex]) {
          items[AppState.autocompleteHighlightIndex].click();
        }
      } else {
        const firstItem = list.querySelector('.autocomplete-item');
        if (firstItem) {
          firstItem.click();
        }
      }
      break;
    case 'Escape':
      list.style.display = 'none';
      DOM.searchInput.blur();
      break;
  }
});

DOM.searchInput.addEventListener('focus', () => {
  if (DOM.searchInput.value.trim()) {
    suggest(DOM.searchInput.value);
  }
});

DOM.clearBtn.addEventListener('click', () => {
  DOM.searchInput.value = '';
  DOM.clearBtn.style.display = 'none';
  DOM.autocompleteList.style.display = 'none';
  DOM.searchInput.focus();
});

DOM.sheetHandle.addEventListener('click', toggleInfoSheet);
DOM.sheetHandle.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    toggleInfoSheet();
  }
});

DOM.infoSheet.addEventListener('touchstart', (e) => {
  AppState.touchStartY = e.touches[0].clientY;
  AppState.sheetStartY = DOM.infoSheet.getBoundingClientRect().top;
  AppState.isDraggingSheet = true;
});

DOM.infoSheet.addEventListener('touchmove', (e) => {
  if (!AppState.isDraggingSheet) return;
  
  const currentY = e.touches[0].clientY;
  const diff = currentY - AppState.touchStartY;
  
  if (diff > 0) {
    DOM.infoSheet.style.transform = `translateY(${diff}px)`;
  }
});

DOM.infoSheet.addEventListener('touchend', (event) => {
  AppState.isDraggingSheet = false;
  DOM.infoSheet.style.transform = '';
  
  if (event.changedTouches.length > 0) {
    const endY = event.changedTouches[0].clientY;
    const diff = endY - AppState.touchStartY;
    
    if (diff > CONFIG.TOUCH_SWIPE_THRESHOLD) {
      closeInfoSheet();
    }
  }
});

DOM.closeBtn.addEventListener('click', closeInfoSheet);

DOM.copyBtn.addEventListener('click', async () => {
  if (!AppState.currentSite) return;
  
  try {
    const coords = `${AppState.currentSite.lat.toFixed(6)}, ${AppState.currentSite.lng.toFixed(6)}`;
    await navigator.clipboard.writeText(coords);
    showCopySuccess();
  } catch (err) {
    console.error('Failed to copy coordinates:', err);
    showError('Failed to copy coordinates. Please try again.');
  }
});

document.addEventListener('click', (e) => {
  if (!e.target.closest('.search-card') && !e.target.closest('.autocomplete-list')) {
    DOM.autocompleteList.style.display = 'none';
  }
});

map.addEventListener('click', () => {
  if (window.innerWidth < 900) {
    closeInfoSheet();
  }
});

window.addEventListener('resize', () => {
  map.invalidateSize();
});

// ============================================================================
// INITIALIZATION
// ============================================================================

DOM.searchInput.setAttribute('autocomplete', 'off');

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', load);
} else {
  load();
}

document.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
    e.preventDefault();
    DOM.searchInput.focus();
  }
  
  if (e.key === 'Escape' && DOM.infoSheet.classList.contains('open')) {
    closeInfoSheet();
  }
});

console.log('RQpedia v2.0.0 - Enhanced Archaeological Sites Database with Dynamic Analytics');
console.log('Features: Tabbed interface, data visualizations, comprehensive statistics');
</script>
</body>
</html>
