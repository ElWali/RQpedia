<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Test for sites.html</title>
    <link rel="stylesheet" href="https://unpkg.com/qunit@2.20.0/qunit/qunit.css">
</head>
<body>
    <div id="qunit"></div>
    <div id="qunit-fixture"></div>

    <script src="https://unpkg.com/qunit@2.20.0/qunit/qunit.js"></script>

    <!-- Mock the DOM elements required by the script -->
    <div style="display: none;">
        <select id="site-selector"></select>
        <div id="selected-count"></div>
        <input id="search-filter" />
        <div id="sites-table-body"></div>
        <div id="loader"></div>
        <button id="scrollTopBtn"></button>
        <table>
            <thead>
                <tr>
                    <th data-sort-by="name">Name</th>
                    <th data-sort-by="country">Country</th>
                    <th data-sort-by="coordinates">Coordinates</th>
                </tr>
            </thead>
        </table>
    </div>

    <script type="module">
        import { parseMalformedJson } from '../VX/parser.js';

        // --- Logic extracted from sites.html ---
        let sites = [], filteredSites = [], currentIndex = 0;
        const rowsPerBatch = 30;
        let rowsLoaded = 0;
        let currentSort = { column:'name', order:'asc' };

        function processData(data){
            const map = new Map();
            data.forEach(item=>{
                if(!map.has(item.site)) map.set(item.site,{id: item.id, name:item.site,country:item.country,lat:parseFloat(item.lat),lng:parseFloat(item.lng),radiocarbonDates:0,typologicalDates:0});
                const s = map.get(item.site);
                if(item.c14) s.radiocarbonDates+=parseMalformedJson(item.c14).length;
                else s.typologicalDates+=parseMalformedJson(item.periods).length;
            });
            return Array.from(map.values());
        }

        function sortData(){
            filteredSites.sort((a,b)=>{
                if (currentSort.column === 'coordinates') {
                    const dir = currentSort.order === 'asc' ? 1 : -1;
                    if (a.lat > b.lat) return 1 * dir;
                    if (a.lat < b.lat) return -1 * dir;
                    if (a.lng > b.lng) return 1 * dir;
                    if (a.lng < b.lng) return -1 * dir;
                    return 0;
                }
                let aV=a[currentSort.column],bV=b[currentSort.column];
                if(typeof aV==='string'){aV=aV.toLowerCase();bV=bV.toLowerCase();}
                return (aV<bV?-1:aV>bV?1:0)*(currentSort.order==='asc'?1:-1);
            });
        }

        // --- QUnit Tests ---
        QUnit.module('Sorting Logic', function() {
            QUnit.test('should sort coordinates by latitude then longitude', function(assert) {
                const testData = [
                    { "id": 1, "site": "Site A", "country": "Country X", "lat": "34.0", "lng": "9.0" },
                    { "id": 2, "site": "Site B", "country": "Country Y", "lat": "32.0", "lng": "10.0" },
                    { "id": 3, "site": "Site C", "country": "Country Z", "lat": "34.0", "lng": "8.0" }
                ];

                sites = processData(testData);
                filteredSites = [...sites];

                // --- Test ascending sort ---
                currentSort = { column: 'coordinates', order: 'asc' };
                sortData();

                let names = filteredSites.map(s => s.name);
                assert.deepEqual(names, ['Site B', 'Site C', 'Site A'], 'Ascending Sort Order is correct');

                // --- Test descending sort ---
                currentSort = { column: 'coordinates', order: 'desc' };
                sortData();

                names = filteredSites.map(s => s.name);
                assert.deepEqual(names, ['Site A', 'Site C', 'Site B'], 'Descending Sort Order is correct');
            });
        });
    </script>
</body>
</html>
